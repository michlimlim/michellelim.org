<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>How We Built Our Own Time-Tracking Algorithm for a Rust app - Michelle Lim</title><link rel=icon type=image/png href=/icons/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1">
<meta property="og:title" content="How We Built Our Own Time-Tracking Algorithm for a Rust app"><meta property="og:description" content="A technical blog post on how we built time-tracking for an app"><meta property="og:type" content="article"><meta property="og:url" content="https://michellelim.dev/writing/measure-time-spent-in-app/"><meta property="og:image" content="https://michellelim.dev/images/time-spent/persistence-of-memory.jpeg"><meta property="article:section" content="writing"><meta property="article:published_time" content="2023-05-09T22:37:35-04:00"><meta property="article:modified_time" content="2023-05-09T22:37:35-04:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://michellelim.dev/images/time-spent/persistence-of-memory.jpeg"><meta name=twitter:title content="How We Built Our Own Time-Tracking Algorithm for a Rust app"><meta name=twitter:description content="A technical blog post on how we built time-tracking for an app"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://michellelim.dev/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://michellelim.dev/css/main.css><link rel=stylesheet type=text/css href=https://michellelim.dev/css/custom.css><link rel=stylesheet type=text/css href=https://michellelim.dev/css/dark.css media="(prefers-color-scheme: dark)"><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=https://michellelim.dev/js/main.js></script><script src=https://platform.twitter.com/widgets.js></script></head><body><div class="container wrapper post"><div class=header><base href=https://michellelim.dev/><div class=site-description><h1 class=site-title><a href=https://michellelim.dev/>Michelle Lim</a></h1><nav class="nav social"><ul class=flat><a href=https://twitter.com/michlimlim title=Twitter><i data-feather=twitter></i></a><a href=https://linkedin.com/in/michlimlim title=Linkedin><i data-feather=linkedin></i></a><a href=https://github.com/michlimlim title=Github><i data-feather=github></i></a><a href=mailto:limxlmichelle@gmail.com title=Email><i data-feather=mail></i></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>Home</a></li><li><a href=/writing>Writing</a></li><li><a href=/projects>Projects</a></li><li><a href=/investments>Investments</a></li><li><a href=/art>Art</a></li><li><a href=/subscribe>Subscribe</a></li></ul></nav></div><div class=post-header><h1 class=title>How We Built Our Own Time-Tracking Algorithm for a Rust app</h1><div class=meta>Posted at &mdash; May 9, 2023</div></div><div class=markdown><p><img src=/images/time-spent/persistence-of-memory.jpeg alt="Peristence of Memory by Dalí"></p><p>In 2021, I was working on a start-up that was building a desktop app. At one point, an investor asked us how much time users were spending in the app daily. Our existing optional telemetry couldn’t tell us. But we knew figuring it out would tell us if our app was useful.</p><p>Ideally, we would have reached for an off-the-shelf SDK from a telemetry provider to solve this for us. However, our app was written in Rust, whose package ecosystem is still developing. Our best shot would have been refactoring a Swift package for iOS to target Mac OS, but that would’ve added unnecessary complexity. We decided to write our own.</p><h3 id=initial-approaches>Initial approaches</h3><p>The naive implementation is to send heartbeat requests to the backend when the app is being used. However, it would’ve been too costly. We had to write data to our analytics service’s API, but the service charges by volume. The heartbeat solution would’ve generated too many events and eaten away our runway. We could’ve extended the heartbeat interval to decrease events but it would’ve cost us in accuracy. So we ditched the heartbeat solution.</p><p>The next best idea would be logging an event when usage starts and another event when usage ends. We could log an event when the app is focused and another when the app is unfocused. But this overestimates usage because a user could leave an app focused overnight but not <em>use</em> it. Moreover, this method is also sensitive to missing events: if the app crashes<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> before the app is unfocused, we will lose track of that period of usage.</p><h3 id=sessionization>Sessionization</h3><p>Instead, we can take advantage of usage events the client has already been sending to the analytics service. The idea is that we assume events happening within a window are part of the same session. Say we mark any two events that are less than 5 min apart as part of the same session. It would be reasonable to assume that the user is engaged with the app between those events.</p><p>If an event does not happen within 5 min after the last event, we would consider that the session terminated.</p><p><img src=/images/time-spent/time-spent-event-sessionization.png alt="Event Sessionization">
<em>In this scenario, a client emits the events A, B, and C within 5 min of each other, and then emits Event D 6 min after. The first 3 actions are part of Session 1 which is the duration between A and C. And the last event is the start of a new session.</em></p><p>There are two scenarios where this approach can fail, but, in our case, they were deemed acceptable.</p><p>On the one hand, a user who checks in on the app at least once every 5 min, but is switching between multiple apps would cause their time spent in the app to be overestimated. However, we are okay with this kind of error since the ultimate goal is to measure engagement, and a user who is checking in that often is clearly engaged for the entire duration, even if they are multitasking.</p><p>On the flip side, if a user pauses to think for 6 min before clicking their next request-generating button, their actions would be counted as part of two separate sessions. The 6-min duration would not be counted as time spent using the app, even though the user was actively engaged the entire time. This could have been a real problem for us, but we found that in practice these kinds of pauses were rare.</p><h3 id=first-attempt>First attempt</h3><p>We can tag on session information to each event. For each event, we tag it with the last session if it occurred within 5min of the last timestamp. We tag it with a new session timestamp otherwise.</p><script src=https://gist.github.com/michlimlim/05a3cd1c10866d4d3c65d5f399853f3f.js></script><h3 id=second-attempt>Second attempt</h3><p>However, this approach under-recorded time spent since it did not account for <strong>all</strong> user activity. It only considered the activity of using flagship features, but did not account for regular user actions like typing or focusing the app.</p><p>We could send an event for each keystroke or window interaction, but this will flood our data warehouse. Instead, we decided to sample these events (let’s call them “App Active” events) at a coarser interval, e.g. 1min<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p>We enqueued an App Active event to our telemetry queue only if the user performed any app active action within the last minute. We also merged redundant events: two consecutive App Active events in the same session gives us the same information as one. Similarly, an App Active event followed by a flagship usage event gives the same information as just the flagship usage event.</p><p><img src=/images/time-spent/time-spent-queue.png alt="Time spent queue"></p><p>Here’s how the code looked like:</p><script src=https://gist.github.com/michlimlim/0456089d16859cacb5558ee328bff819.js></script><h3 id=conclusion>Conclusion</h3><p>Once we shipped this, we were able to visualize users’ time spent in the app<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> with low event volume.</p><p>We found that our users use our app for a substantive part of their work days, and verified that our app was useful.</p><p><img src=/images/time-spent/time-spent-chart.png alt="Time spent chart"></p><p>References:</p><p><a href=https://medium.com/analytics-and-data/effective-approaches-to-dealing-with-tracking-time-spent-on-content-and-webpages-695f63c02b8a>https://medium.com/analytics-and-data/effective-approaches-to-dealing-with-tracking-time-spent-on-content-and-webpages-695f63c02b8a</a></p><h2 id=notes>Notes</h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>We could actually make this resilient to the app <em>closing</em>. We could write a SIGINT handler that saves the last recorded focus duration and sends it to the backend. However, we can’t do the same for app crashes, since a SIGKILL immediately terminates the app process.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Because we built our own UI framework for the app, we were able to plug into the app’s input event handling logic to <a href=https://gist.github.com/michlimlim/e0397ccd3993306b65dcdda431ffa267>keep track of the last action timestamp</a>, and <a href=https://gist.github.com/michlimlim/b2ca54a281264067911ca1d6c6501c50>sample this every 1 min</a>.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Take every session and take the difference between the start time and last event of the session.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=post-tags></div></div><div class="footer wrapper"><div id=mc_embed_signup><form action="https://michellelim.us2.list-manage.com/subscribe/post?u=cf007b8800f2adebe180e8078&amp;id=6540dfdf5c" method=post id=mc-embedded-subscribe-form name=mc-embedded-subscribe-form class=validate target=_blank novalidate><div id=mc_embed_signup_scroll><label for=mce-EMAIL>Subscribe for new writing!</label>
<input type=email name=EMAIL class=email id=mce-EMAIL placeholder="email address" required><div style=position:absolute;left:-5000px aria-hidden=true><input type=text name=b_cf007b8800f2adebe180e8078_6540dfdf5c tabindex=-1></div><div class=clear><input type=submit value=Subscribe name=subscribe id=mc-embedded-subscribe class=button></div></div></form></div><div class=twitter-button><iframe id=twitter-widget-0 scrolling=no frameborder=0 allowtransparency=true allowfullscreen class="twitter-follow-button twitter-follow-button-rendered" style=position:static;visibility:visible;width:150px;height:20px title="Twitter Follow Button" src="https://platform.twitter.com/widgets/follow_button.2b2d73daf636805223fb11d48f3e94f7.en.html#dnt=false&amp;id=twitter-widget-0&amp;lang=en&amp;screen_name=michlimlim&amp;show_count=false&amp;show_screen_name=true&amp;size=m&amp;time=1676239060826" data-screen-name=michlimlim></iframe></div><nav class=nav><div>Copyright © 2024 Michelle Lim's Homepage | <a href=https://github.com/vividvilla/ezhil>Ezhil theme</a></div></nav></div><script>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-177547603-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><script>feather.replace()</script></body></html>